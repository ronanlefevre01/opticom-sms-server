"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = __importDefault(require("node:fs"));
const apiRequestSigning_1 = require("./apiRequestSigning");
const privateKeyPem = node_fs_1.default.readFileSync('src/fixtures/private_key.pem', 'utf8');
const publicKeyPem = node_fs_1.default.readFileSync('src/fixtures/public_key.pem', 'utf8');
const SIG_PATTERN = /^sig-1=:(.+):$/;
const commonOpts = () => ({
    apiRequestSigningOptions: {
        privateKeyPem,
        publicKeyId: 'PublicKeyId',
        publicKeyPem,
    },
    host: 'https://api.example.com',
    requestPath: '/test',
    httpMethod: 'GET',
    contentDigest: null,
    contentLength: 123,
    created: '123',
    nonce: 'nonce',
    contentType: 'application/json',
});
describe('.new', () => {
    describe('no content', () => {
        test('should generate the signature header', () => {
            const opts = commonOpts();
            const signer = new apiRequestSigning_1.ApiRequestSignatureHelper(opts);
            // @ts-ignore
            const signature = signer._gcSignature;
            expect(signature).toMatch(SIG_PATTERN);
        });
        test('should populate the signature input header', () => {
            const opts = commonOpts();
            const signer = new apiRequestSigning_1.ApiRequestSignatureHelper(opts);
            // @ts-ignore
            const signatureInput = signer._gcSignatureInput;
            expect(signatureInput).toBe(`sig-1=("@method" "@authority" "@request-target");keyid="PublicKeyId";created=123;nonce="nonce"`);
        });
    });
    describe('with content', () => {
        test('should generate the signature header', () => {
            const opts = commonOpts();
            opts.contentDigest = 'digest';
            const signer = new apiRequestSigning_1.ApiRequestSignatureHelper(opts);
            // @ts-ignore
            const signature = signer._gcSignature;
            expect(signature).toMatch(SIG_PATTERN);
        });
        test('should populate the signature input header', () => {
            const opts = commonOpts();
            opts.contentDigest = 'digest';
            const signer = new apiRequestSigning_1.ApiRequestSignatureHelper(opts);
            // @ts-ignore
            const signatureInput = signer._gcSignatureInput;
            expect(signatureInput).toBe(`sig-1=("@method" "@authority" "@request-target" "content-digest" "content-type" "content-length");keyid="PublicKeyId";created=123;nonce="nonce"`);
        });
    });
    describe('with test mode', () => {
        test("should generate the signature header with 'SIG' in test mode", () => {
            const opts = commonOpts();
            opts.apiRequestSigningOptions.testMode = true;
            const signer = new apiRequestSigning_1.ApiRequestSignatureHelper(opts);
            // @ts-ignore
            const signature = signer._gcSignature;
            expect(signature).toBe('sig-1=:SIG:');
        });
    });
    describe('with public key provided', () => {
        describe('when public key is for the private key', () => {
            test('should not error', () => {
                const opts = commonOpts();
                opts.apiRequestSigningOptions.publicKeyPem = publicKeyPem;
                expect(() => new apiRequestSigning_1.ApiRequestSignatureHelper(opts)).not.toThrow();
            });
        });
        describe('when signing failed', () => {
            afterEach(() => jest.restoreAllMocks());
            test('should throw an error', () => {
                const opts = commonOpts();
                opts.apiRequestSigningOptions.publicKeyPem = publicKeyPem;
                jest
                    .spyOn(apiRequestSigning_1.ApiRequestSignatureHelper.prototype, 'signStringSecp521r1')
                    .mockImplementation((_a, _b) => 'invalid-signature');
                expect(() => new apiRequestSigning_1.ApiRequestSignatureHelper(opts)).toThrow('Signature verification failed');
            });
        });
    });
});
describe('.getSignature', () => {
    test('returns the signature header', () => {
        const signer = new apiRequestSigning_1.ApiRequestSignatureHelper(commonOpts());
        // @ts-ignore
        const signature = signer._gcSignature;
        const gcSignatureHeader = signer.getGcSignature();
        expect(gcSignatureHeader).toBe(signature);
    });
});
describe('.getGcSignatureInput', () => {
    test('returns the signature input header', () => {
        const signer = new apiRequestSigning_1.ApiRequestSignatureHelper(commonOpts());
        // @ts-ignore
        const signatureInput = signer._gcSignatureInput;
        const gcSignatureHeader = signer.getGcSignatureInput();
        expect(gcSignatureHeader).toBe(signatureInput);
    });
});
describe('.getSha256DigestHeader', () => {
    test('wraps digest into expected format', () => {
        const digest = 'digest';
        const header = apiRequestSigning_1.ApiRequestSignatureHelper.getSha256DigestHeader(digest);
        expect(header).toBe(`sha256=:${digest}:`);
    });
});
describe('getSha256Digest', () => {
    test('generates a sha256 digest of a string', () => {
        const content = 'test content';
        const digest = apiRequestSigning_1.ApiRequestSignatureHelper.getSha256Digest(content);
        expect(digest).toBe('auinVVUgn9bEQVfArtgBbnY/9DWhnPGG92hjFAFD/3I=');
    });
    describe('given non-string content', () => {
        test('throws TypeError', () => {
            expect(() => apiRequestSigning_1.ApiRequestSignatureHelper.getSha256Digest(123)).toThrow(TypeError);
        });
    });
});
//# sourceMappingURL=apiRequestSigning.test.js.map